# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/anyex/anyex/blob/master/CONTRIBUTING.md#how-to-contribute-code

from anyex.base.exchange import Exchange
import base64
import hashlib
import json
from anyex.base.errors import ExchangeError
from anyex.base.errors import NotSupported
from anyex.base.errors import AuthenticationError
from anyex.base.errors import InsufficientFunds
from anyex.base.errors import InvalidOrder
from anyex.base.errors import OrderNotFound


class kkex (Exchange):

    def describe(self):
        return self.deep_extend(super(kkex, self).describe(), {
            'id': 'kkex',
            'name': 'KKEX',
            'countries': 'CN',
            'rateLimit': 240,
            # 'userAgent': self.userAgents['chrome'],
            'has': {
                'CORS': True,
                'fetchOHLCV': True,
                'deposit': True,
                'withdraw': True,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
                'fetchMyTrades': True,
            },
            'timeframes': {
                '1m': 60,
                '5m': 300,
                '15m': 900,
                '1h': 3600,
                '6h': 21600,
                '1d': 86400,
            },
            'urls': {
                'api': 'https://kkex.com/api',
                'www': 'https://www.kkex.com',
                'doc': 'https://kkex.com/api_wiki/',
                'fees': [
                    'https://intercom.help/kkex/fee',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'v1/chart_feed/config',
                        'v1/chart_feed/time',
                        'v1/chart_feed/symbols',
                        'v1/chart_feed/history',
                        'v1/products',
                        'v1/assets',
                        'v1/exchange_rate',
                        'v1/ticker',
                        'v1/tickers',
                        'v1/depth',
                        'v1/trades',
                        'v1/kline',
                        'v1/orderbook',
                    ],
                },
                'private': {
                    'post': [
                        'v2/profile',
                        'v2/userinfo',

                        'v2/trade',
                        'v2/batch_trade',
                        'v2/cancel_order',
                        'v2/cancel_all_orders',
                        'v2/order_info',
                        'v2/orders_info',
                        'v2/order_history',
                        'v2/download_orders',

                        'v2/withdraw',
                        'v2/withdraw_info',

                        'v2/process_strategy',
                        'v2/cancel_strategy',
                        'v2/batch_cancel_strategy',
                        'v2/history_strategy',
                        'v2/strategy_param',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'taker': 0.002,
                    'maker': 0.002,
                },
            }
        })

    def fetch_markets(self):
        response = self.publicGetV1Products()
        markets = response['all_products']
        result = []
        for p in range(0, len(markets)):
            market = markets[p]
            id = market['symbol']
            # kkex use base/quote in the wrong way
            base = self.common_currency_code(market['mark_asset'])
            quote = self.common_currency_code(market['base_asset'])
            symbol = base + '/' + quote
            precision = {
                'amount': 8,
                'price': 8,
            }
            limits = {
                # kkex has both bid_amount and bid_size limits
                'amount': {
                    'min': self.safe_float(market, 'min_bid_size'),
                    'max': self.safe_float(market, 'max_bid_size'),
                },
                'price': {
                    'min': self.safe_float(market, 'min_price'),
                    'max': self.safe_float(market, 'max_price'),
                }
            }
            limits['cost'] = {
                'min': limits['amount']['min'] * limits['price']['min'],
                'max': None,
            }
            taker = self.fees['trading']['taker']
            maker = self.fees['trading']['maker']
            active = market['status'] == 'OPEN'
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'precision': precision,
                'limits': limits,
                'taker': taker,
                'maker': maker,
                'active': active,
                'info': market,
            })
        return result

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privatePostV2Userinfo()
        result = {'info': response}
        currencies = list(self.currencies.keys())
        balances = response['info']['funds']
        for i in range(0, len(currencies)):
            currency = currencies[i]
            account = self.account()
            if currency in balances['freezed']:
                account['free'] = float(balances['free'][currency])
                account['used'] = float(balances['freezed'][currency])
                account['total'] = float(account['free']) + float(account['used'])
            result[currency] = account
        return self.parse_balance(result)

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'size': 20
            # 'merge': 0.00000001
        }
        orderbook = self.publicGetV1Depth(self.extend(request, params))
        return self.parse_order_book(orderbook, self.msec())

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = self.extend({
            'symbol': market['id'],
        }, params)
        response = self.publicGetV1Ticker(request)
        ticker = response['ticker']
        return {
            'symbol': symbol,
            'timestamp': response['date'],
            'datetime': self.iso8601(response['date'] * 1000),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': self.safe_float(ticker, 'buy'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'sell'),
            'askVolume': None,
            'vwap': None,
            'open': self.safe_float(ticker, 'open'),
            'close': None,
            'last': self.safe_float(ticker, 'last'),
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, 'vol'),
            'quoteVolume': None,
            'info': ticker,
        }

    def parse_order_status(self, status):
        statuses = {
            0: 'open',
            1: 'open',
            2: 'closed',
            4: 'open',
            -1: 'canceled',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        timestamp = order['create_date']
        symbol = order['symbol']
        status = self.parse_order_status(order['status'])
        price = self.safe_float(order, 'price')
        amount = self.safe_float(order, 'amount')
        filled = self.safe_float(order, 'deal_amount')
        remaining = amount - filled
        cost = None
        fee = None
        if market:
            symbol = market['symbol']
        return {
            'id': order['order_id'],
            'info': order,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': 'market' if order['type'].endswith('market') else 'limit',
            'side': order['type'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'fee': fee,
        }

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        order = {
            'order_id': id,
            'symbol': self.market_id(symbol)
        }
        response = self.privatePostV2OrderInfo(self.extend(order, params))
        return self.parse_order(response['order'], market)

    def fetch_orders(self, order_ids=[], symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        if not isinstance(order_ids, list):
            raise ExchangeError(self.id + ' order_ids should be a list!')

        order_ids = ','.join([str(i) for i in order_ids])
        orders = {
            'symbol': self.market_id(symbol),
            'order_id': order_ids
        }
        response = self.privatePostV2OrdersInfo(self.extend(orders, params))
        return self.parse_orders(response['orders'], market, since, limit)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        order = {
            'symbol': self.market_id(symbol),
            'side': side,
            'amount': amount,
            'type': side,
            'price': price
        }
        if type == 'market':
            order['type'] = side + '_market'
        response = self.privatePostV2Trade(self.extend(order, params))
        return {
            'info': response,
            'id': response['order_id']
        }

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        order = {
            'order_id': id,
            'symbol': self.market_id(symbol),
        }
        return self.privatePostV2CancelOrder(self.extend(order, params))

    def cancel_orders(self, symbol=None, params={}):
        self.load_markets()
        order = {
            'symbol': self.market_id(symbol)
        }
        return self.privatePostV2CancelAllOrders(self.extend(order, params))

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = '/'
        url += path
        if api == 'private':
            self.check_required_credentials()
            query = self.keysort(self.extend({
                'api_key': self.apiKey,
                'nonce': self.nonce(),
            }, params))
            # secret key must be at the end of query
            queryString = self.rawencode(query) + '&secret_key=' + self.secret
            query['sign'] = self.hash(self.encode(queryString)).upper()
            body = self.urlencode(query)
            headers = {'Content-Type': 'application/x-www-form-urlencoded'}
            url += '?' + self.urlencode(query)
        else:
            if params:
                url += '?' + self.urlencode(params)
        url = self.urls['api'] + url
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    # def parse_trade(self, trade, market=None):
    #     timestamp = None
    #     if 'time' in trade:
    #         timestamp = self.parse8601(trade['time'])
    #     elif 'created_at' in trade:
    #         timestamp = self.parse8601(trade['created_at'])
    #     iso8601 = None
    #     if timestamp is not None:
    #         iso8601 = self.iso8601(timestamp)
    #     symbol = None
    #     if not market:
    #         if 'product_id' in trade:
    #             marketId = trade['product_id']
    #             if marketId in self.markets_by_id:
    #                 market = self.markets_by_id[marketId]
    #     if market:
    #         symbol = market['symbol']
    #     feeRate = None
    #     feeCurrency = None
    #     if market:
    #         feeCurrency = market['quote']
    #         if 'liquidity' in trade:
    #             rateType = 'taker' if (trade['liquidity'] == 'T') else 'maker'
    #             feeRate = market[rateType]
    #     feeCost = self.safe_float(trade, 'fill_fees')
    #     if feeCost is None:
    #         feeCost = self.safe_float(trade, 'fee')
    #     fee = {
    #         'cost': feeCost,
    #         'currency': feeCurrency,
    #         'rate': feeRate,
    #     }
    #     type = None
    #     id = self.safe_string(trade, 'trade_id')
    #     side = 'sell' if (trade['side'] == 'buy') else 'buy'
    #     orderId = self.safe_string(trade, 'order_id')
    #     # GDAX returns inverted side to fetchMyTrades vs fetchTrades
    #     if orderId is not None:
    #         side = 'buy' if (trade['side'] == 'buy') else 'sell'
    #     return {
    #         'id': id,
    #         'order': orderId,
    #         'info': trade,
    #         'timestamp': timestamp,
    #         'datetime': iso8601,
    #         'symbol': symbol,
    #         'type': type,
    #         'side': side,
    #         'price': self.safe_float(trade, 'price'),
    #         'amount': self.safe_float(trade, 'size'),
    #         'fee': fee,
    #     }

    # def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
    #     self.load_markets()
    #     market = None
    #     request = {}
    #     if symbol is not None:
    #         market = self.market(symbol)
    #         request['product_id'] = market['id']
    #     if limit is not None:
    #         request['limit'] = limit
    #     response = self.privateGetFills(self.extend(request, params))
    #     return self.parse_trades(response, market, since, limit)

    # def fetch_trades(self, symbol, since=None, limit=None, params={}):
    #     self.load_markets()
    #     market = self.market(symbol)
    #     response = self.publicGetProductsIdTrades(self.extend({
    #         'id': market['id'],  # fixes issue  #2
    #     }, params))
    #     return self.parse_trades(response, market, since, limit)

    # def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
    #     return [
    #         ohlcv[0] * 1000,
    #         ohlcv[3],
    #         ohlcv[2],
    #         ohlcv[1],
    #         ohlcv[4],
    #         ohlcv[5],
    #     ]

    # def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
    #     self.load_markets()
    #     market = self.market(symbol)
    #     granularity = self.timeframes[timeframe]
    #     request = {
    #         'id': market['id'],
    #         'granularity': granularity,
    #     }
    #     if since is not None:
    #         request['start'] = self.ymdhms(since)
    #         if limit is None:
    #             # https://docs.gdax.com/#get-historic-rates
    #             limit = 300  # max = 300
    #         request['end'] = self.ymdhms(self.sum(limit * granularity * 1000, since))
    #     response = self.publicGetProductsIdCandles(self.extend(request, params))
    #     return self.parse_ohlcvs(response, market, timeframe, since, limit)

    # def fee_to_precision(self, currency, fee):
    #     cost = float(fee)
    #     return('{:.' + str(self.currencies[currency].precision) + 'f}').format(cost)

    # def calculate_fee(self, symbol, type, side, amount, price, takerOrMaker='taker', params={}):
    #     market = self.markets[symbol]
    #     rate = market[takerOrMaker]
    #     cost = amount * price
    #     currency = market['quote']
    #     return {
    #         'type': takerOrMaker,
    #         'currency': currency,
    #         'rate': rate,
    #         'cost': float(self.fee_to_precision(currency, rate * cost)),
    #     }

    # def get_payment_methods(self):
    #     response = self.privateGetPaymentMethods()
    #     return response

    # def deposit(self, currency, amount, address, params={}):
    #     self.load_markets()
    #     request = {
    #         'currency': currency,
    #         'amount': amount,
    #     }
    #     method = 'privatePostDeposits'
    #     if 'payment_method_id' in params:
    #         # deposit from a payment_method, like a bank account
    #         method += 'PaymentMethod'
    #     elif 'coinbase_account_id' in params:
    #         # deposit into GDAX account from a Coinbase account
    #         method += 'CoinbaseAccount'
    #     else:
    #         # deposit methodotherwise we did not receive a supported deposit location
    #         # relevant docs link for the Googlers
    #         # https://docs.gdax.com/#deposits
    #         raise NotSupported(self.id + ' deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params')
    #     response = getattr(self, method)(self.extend(request, params))
    #     if not response:
    #         raise ExchangeError(self.id + ' deposit() error: ' + self.json(response))
    #     return {
    #         'info': response,
    #         'id': response['id'],
    #     }

    # def withdraw(self, currency, amount, address, tag=None, params={}):
    #     self.check_address(address)
    #     self.load_markets()
    #     request = {
    #         'currency': currency,
    #         'amount': amount,
    #     }
    #     method = 'privatePostWithdrawals'
    #     if 'payment_method_id' in params:
    #         method += 'PaymentMethod'
    #     elif 'coinbase_account_id' in params:
    #         method += 'CoinbaseAccount'
    #     else:
    #         method += 'Crypto'
    #         request['crypto_address'] = address
    #     response = getattr(self, method)(self.extend(request, params))
    #     if not response:
    #         raise ExchangeError(self.id + ' withdraw() error: ' + self.json(response))
    #     return {
    #         'info': response,
    #         'id': response['id'],
    #     }

    # def handle_errors(self, code, reason, url, method, headers, body):
    #     if (code == 400) or (code == 404):
    #         if body[0] == '{':
    #             response = json.loads(body)
    #             message = response['message']
    #             error = self.id + ' ' + message
    #             if message.find('price too small') >= 0:
    #                 raise InvalidOrder(error)
    #             elif message.find('price too precise') >= 0:
    #                 raise InvalidOrder(error)
    #             elif message == 'Insufficient funds':
    #                 raise InsufficientFunds(error)
    #             elif message == 'NotFound':
    #                 raise OrderNotFound(error)
    #             elif message == 'Invalid API Key':
    #                 raise AuthenticationError(error)
    #             raise ExchangeError(self.id + ' ' + message)
    #         raise ExchangeError(self.id + ' ' + body)
